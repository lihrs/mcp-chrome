---
name: use-codex
description: 与codex协作，调用codex为你提供的mcp工具作为客观全面分析的保证。当需要进行上下文收集（代码库检索）、需求分析、复杂逻辑架构设计、代码审查、bug分析修复时使用此技能。
---

**IMPORTANT - 你务必执行以下步骤:**

1. 需求分析：在你理解用户需求并自行整理形成初步分析后，将用户需求、初始思路告知codex，并要求其完善需求，形成最终的需求
2. 上下文搜集：根据需求，使用codex对当前项目
3. 在实施具体编码任务前，**必须向codex索要代码实现原型（要求codex仅给出unified diff patch，严禁对代码做任何真实修改）**。在获取代码原型后，你**只能以此为逻辑参考，再次对代码修改进行重写**，形成企业生产级别、可读性极高、可维护性极高的代码后，才能实施具体编程修改任务。
   **3** 无论何时，只要完成切实编码行为后，**必须立即使用codex review代码改动和对应需求完成程度**。
   **4** codex只能给出参考，你**必须有自己的思考，甚至需要对codex的回答提出置疑**。尽信书则不如无书，你与codex的最终使命都是达成统一、全面、精准的意见，所以你们必须不断争辩已找到通向真理的唯一途径。

# Codex Collaboration Skill

## 功能概述

本 skill 封装了与 Codex 协作的完整流程和规范，让主AI能够：

- 进行深度分析和复杂推理
- 收集和管理上下文信息
- 设计复杂逻辑（>10行核心逻辑）
- 执行代码质量审查和风险评估
- 自动化执行协作流程

## 工具描述

1. 工具简介

codex MCP 提供了一个工具 `codex`，用于执行 AI 辅助的编码任务。该工具**通过 MCP 协议调用**，无需使用命令行。

2. 工具参数

**必选**参数：

- PROMPT (string): 发送给 codex 的任务指令
- cd (Path): codex 执行任务的工作目录根路径

可选参数：

- sandbox (string): 沙箱策略，可选值：
  - "read-only" (默认): 只读模式，最安全
  - "workspace-write": 允许在工作区写入
  - "danger-full-access": 完全访问权限
- SESSION_ID (UUID | null): 用于继续之前的会话以与codex进行多轮交互，默认为 None（开启新会话）
- skip_git_repo_check (boolean): 是否允许在非 Git 仓库中运行，默认 False
- return_all_messages (boolean): 是否返回所有消息（包括推理、工具调用等），默认 False

返回值：
{
"success": true,
"SESSION_ID": "uuid-string",
"agent_messages": "agent回复的文本内容",
"all_messages": [] // 仅当 return_all_messages=True 时包含
}
或失败时：
{
"success": false,
"error": "错误信息"
}

3. 使用方式

开启新对话：

- 不传 SESSION_ID 参数（或传 None）
- 工具会返回新的 SESSION_ID 用于后续对话

继续之前的对话：

- 将之前返回的 SESSION_ID 作为参数传入
- 同一会话的上下文会被保留

4. 调用规范

**必须遵守**：

- 每次调用 codex 工具时，必须保存返回的 SESSION_ID，以便后续继续对话
- cd 参数必须指向存在的目录，否则工具会静默失败
- 严禁codex对代码进行实际修改，使用 sandbox="read-only" 以避免意外，并要求codex仅给出unified diff patch即可

推荐用法：

- 如需详细追踪 codex 的推理过程和工具调用，设置 return_all_messages=True
- 对于精准定位、debug、代码原型快速编写等任务，优先使用 codex 工具

5. 注意事项

- 会话管理：始终追踪 SESSION_ID，避免会话混乱
- 工作目录：确保 cd 参数指向正确且存在的目录
- 错误处理：检查返回值的 success 字段，处理可能的错误

## 协作流程

### 1. 需求理解/澄清/讨论

- 快速通道：简单任务（<30字，单一目标）直接进入上下文收集
- 复杂任务：先充分理解需求，形成初步分析，将用户需求、初始思路告知codex，并要求其完善需求分析，要客观，如果你觉得codex分析的不合理，你可以推翻，并且跟他继续讨论，直到把所有细节都明确了为止

### 2. 上下文收集

- 上下文收集：结合分析完的需求，将你可能需要的上下文告知codex，让它对当前项目进行扫描，你先识别关键疑问 → 用Codex 针对性深挖（≤3次）→ 你再做充分性检查

#### 渐进式上下文收集流程

### 核心哲学

- **问题驱动**：基于关键疑问收集，而非机械执行固定流程
- **充分性优先**：追求"足以支撑决策和规划"，而非"信息100%完整"
- **动态调整**：根据实际需要决定深挖次数（建议≤3次），避免过度收集
- **成本意识**：每次深挖都要明确"为什么需要"和"解决什么疑问"

### 步骤1：结构化快速扫描（必须）

- 位置：涉及到改动、新增的功能在哪个模块/文件？
- 现状：现在如何实现？找到1-2个相似案例
- 技术栈：使用的框架、语言、关键依赖
- **观察报告**：Codex 作为专家，报告发现的异常、信息不足之处和建议深入的方向

### 步骤2：识别关键疑问（必须）

根据需求，识别关键疑问：

- 我理解了什么？（已知）
- 还有哪些疑问影响规划？（未知）
- 这些疑问的优先级如何？（高/中/低）
- 输出：优先级排序的疑问列表

### 步骤3：针对性深挖（按需，建议≤3次）

仅针对高优先级疑问，通过 Codex 深挖：

- 聚焦单个疑问，不发散
- 提供代码片段证据，而非猜测

### 3. 任务规划

- 在进入任务规划前，先盘算一下：
  我能定义清晰的类、函数或者接口契约吗？（知道输入输出、参数约束、返回值类型）
  我理解关键技术选型的理由吗？（为什么用这个方案？为什么有多种实现？）
  我识别了主要风险点吗？（并发、边界条件、性能瓶颈）
  我知道如何验证实现吗？（验证方式、覆盖标准）
- 分析 codex 提供的上下文，进行初步的任务规划
- 询问 codex 对规划的任务是否有补充和有异议
- 结合 codex 的返回整理出最终的规划

### 4. 代码编写

- 实施具体编码任务前，**必须向codex索要代码实现原型（要求codex仅给出unified diff patch，严禁对代码做任何真实修改）**。在获取代码原型后，你**只能以此为逻辑参考，再次对代码修改进行重写**，形成企业生产级别、可读性极高、可维护性极高、模块拆分合理、架构设计顶级的代码后，才能实施具体编程修改任务。

### 5. 质量验证

- 无论何时，只要完成切实编码行为后，**必须立即使用codex review代码改动和对应需求完成程度**

## 使用示例

### 深度分析示例

```
分析当前项目和代码架构，识别出架构不合理、代码质量差、可维护性低、扩展性差等需要改进的地方
```

### bug修改实例

```
当前的xxx功能存在一个xxx的bug，仔细分析一下当前的代码，修复这个bug
```

### 需求讨论和架构设计

```
我准备实现一个xxx的功能，你继续当前项目，帮我做个具体的需求分析和设计

```

---

_本 skill 专注于 Codex 协作流程，确保进行上下文收集（代码库检索）、需求分析、复杂逻辑架构设计、代码审查、bug分析修复的标准化和高效执行。_
